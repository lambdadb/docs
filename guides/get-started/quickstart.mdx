---
title: Quickstart
---

This guide will walk you through creating your first collection and performing hybrid search queries. You'll learn to set up collections with text, keyword, and dense vector components, then execute both full-text and hybrid searches that combine traditional search with modern vector similarity.

## üöÄ Step 1: Install the SDK

The LambdaDB SDK provides convenient access to the LambdaDB APIs.

<CodeGroup>

```python Python
pip install lambdadb
```

```typescript TypeScript
npm install @functional-systems/lambdadb
```

</CodeGroup>

<Tip>
    For Python, we recommend using a virtual environment to keep your dependencies organized and avoid conflicts between projects.
</Tip>

## üîë Step 2: Get your API key

To use LambdaDB, you'll need an API key. Fill out [this form](https://share-na2.hsforms.com/1vBeXGa1ETXupo4_mIrtoEA40td9f) to obtain playground credentials.

<Note>
    Keep your API key secure and consider storing it in environment variables rather than hardcoding it in your scripts.
</Note>

<Warning>

    The playground project is publicly accessible and rate limited. Do not store any sensitive/production data to the playground project.

</Warning>

## üìö Step 3: Create a collection

A collection is where you'll store your documents and define how they should be indexed for search. LambdaDB supports 9 different index types: text, keyword, long, double, boolean, object, datetime, dense vector, and sparse vector.

Let's create a collection that combines text search with vector similarity:

<CodeGroup>

```python Python
from lambdadb import LambdaDB, models

# Initialize the LambdaDB client
lambda_db = LambdaDB(
    server_url="your_project_url_here", # Replace with your project url
    project_api_key="your_api_key_here"  # Replace with your actual API key
)

collection_name = "your_collection_name_here" # Replace with unique project name

# Create collection with text and vector indexes
res = lambda_db.collections.create(
    collection_name=collection_name,
    index_configs={
        "text": {
            "type": models.TypeText.TEXT,
            "analyzers": [
                models.Analyzer.ENGLISH,  # English text support
                models.Analyzer.KOREAN    # Korean text support
            ],
        },
        "keyword": {
            "type": models.Type.KEYWORD
        }
        "vector": {
            "type": models.TypeVector.VECTOR,
            "dimensions": 10,                        # Vector dimension
            "similarity": models.Similarity.COSINE,  # Cosine similarity metric
        },
    }
)
print(res)
```

```typescript TypeScript
import { LambdaDB } from "@functional-systems/lambdadb";

// Initialize the LambdaDB client
const lambdaDB = LambdaDB({
    serverURL: "your_project_url_here", // Replace with your project url
    projectApiKey: "your_api_key_here"  // Replace with your actual API key
})

const collectionName = "your_collection_name_here" // Replace with unique project name

// Create collection with text and vector indexes
res = await lambdaDB.collections.create({
    collectionName: collectionName,
    indexConfigs: {
        text: {
            type: "text",
            analyzers: [
                "english",  // English text support
                "korean"    // Korean text support
            ],
        },
        keyword: {
            type: "keyword"
        },
        vector: {
            type: "vector",
            dimensions: 10,                        // Vector dimension
            similarity: "cosine",  // Cosine similarity metric
        },
    }
})
console.log(res)
```
</CodeGroup>

Response:

<CodeGroup>
```python Python
CreateCollectionResponse(
    collection=CollectionResponse(
        project_name='playground',
        collection_name='quickstart',
        index_configs={
            'text': IndexConfigsText(
                type=<TypeText.TEXT: 'text'>,
                analyzers=[<Analyzer.ENGLISH: 'english'>, <Analyzer.KOREAN: 'korean'>]
            ),
            'keyword': IndexConfigs(type=<Type.KEYWORD: 'keyword'>),
            'vector': IndexConfigsVector(
                type=<TypeVector.VECTOR: 'vector'>,
                dimensions=10,
                similarity=<Similarity.COSINE: 'cosine'>
            ),
            'id': IndexConfigs(type=<Type.KEYWORD: 'keyword'>)
        },
        num_docs=0,
        collection_status=<Status.CREATING: 'CREATING'>,
        source_project_name=None,
        source_collection_name=None,
        source_collection_version_id=None
    )
)
```
```typescript TypeScript
{
  collection: {
    projectName: 'playground',
    collectionName: 'quickstart',
    indexConfigs: { text: [Object], keyword: [Object], vector: [Object], id: [Object] },
    numDocs: 0,
    collectionStatus: 'CREATING'
  }
}
```
</CodeGroup>

**Key configuration details:**
- **Text field**: Supports multilingual search with English and Korean analyzers
- **Vector field**: 10-dimensional vectors using cosine similarity
- **Keyword field**: Added to support exact match filtering.

## üìÑ Step 4: Add documents

Now let's add some sample documents. Each document contains text for full-text search, keywords for filtering, and vectors for similarity search:

<CodeGroup>
```python Python
# Prepare sample documents
docs = [
    {
        "id": "doc1",
        "text": "Serverless computing does not mean no servers are involved. It refers to a cloud computing model where the server management is abstracted away from developers.",
        "keyword": "serverless",
        "vector": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    },
    {
        "id": "doc2",
        "text": "Instead, it refers to a cloud computing model where developers can build and run applications without having to manage the underlying infrastructure.",
        "keyword": "cloud",
        "vector": [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1]
    },
    {
        "id": "doc3",
        "text": "The key aspect is that developers don't need to explicitly provision or manage servers. The cloud provider handles all server management automatically.",
        "keyword": ["serverless", "infrastructure"],  # Multiple keywords supported
        "vector": [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2]
    }
]

# Upload documents to the collection
res = lambda_db.collections.docs.upsert(
    collection_name=collection_name,
    docs=docs
)
print(res)
```
```typescript TypeScript
// Prepare sample documents
const docs = [
    {
        id: "doc1",
        text: "Serverless computing does not mean no servers are involved. It refers to a cloud computing model where the server management is abstracted away from developers.",
        keyword: "serverless",
        vector: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    },
    {
        id: "doc2",
        text: "Instead, it refers to a cloud computing model where developers can build and run applications without having to manage the underlying infrastructure.",
        keyword: "cloud",
        vector: [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1]
    },
    {
        id: "doc3",
        text: "The key aspect is that developers don't need to explicitly provision or manage servers. The cloud provider handles all server management automatically.",
        keyword: ["serverless", "infrastructure"],  # Multiple keywords supported
        vector: [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2]
    }
]

// Upload documents to the collection
res = await lambdaDB.collections.docs.upsert({
    collectionName: collectionName,
    requestBody: {
        docs: docs
    }
})
console.log(res)
```
</CodeGroup>

Response:

<CodeGroup>
```python Python
MessageResponse(message='Upsert request is accepted')
```
```typescript TypeScript
{
    message: "Upsert request is accepted"
}
```
</CodeGroup>

**Important notes:**

- **Upsert behavior**: Documents with the same ID will be updated; new IDs create new documents.
- **Auto-generated IDs**: If you don't provide an ID, one will be generated automatically.
- **Bulk operations**: For large-scale document ingestion (5MB+), use the bulk-upsert functionality.
- **Configurable consistency**: LambdaDB is eventually consistent by default, so there can be a slight delay before new or changed documents are visible to queries. 
If your application requires strong (read-after-write) consistency, set `consistentRead` to `true` when query or fetch data from a collection. 

**Check indexing status:** You can view collection stats to verify that your documents have been indexed:

<CodeGroup>
```python Python
# Check collection status and document count
res = lambda_db.collections.get(collection_name=collection_name)
print(res)
```
```typescript TypeScript
// Check collection status and document count
res = lambdaDB.collections.get({collectionName: collectionName})
console.log(res)
```
</CodeGroup>

## üîç Step 5: Full-text search

Let's search for documents that match "I hate managing servers" while filtering for documents tagged exactly with "serverless". This demonstrates LambdaDB's powerful query capabilities:

<CodeGroup>
```python Python
res = lambda_db.collections.query(
    collection_name=collection_name,
    size=10,
    query={
        "bool": [
            {
                "queryString": {
                    "query": "I hate managing servers",  # Main search query
                    "defaultField": "text"               # Search in text field
                }
            },
            {
                "queryString": {
                    "query": "keyword:serverless"       # Filter by keyword
                },
                "occur": "must"
            }
        ]
    }
)

# Display results
print("üîç Search Results:")
for result in res.docs:
    doc_id = str(result.doc['id'])
    score = f"{result.score:.2f}"
    keyword = str(result.doc['keyword'])
    text = str(result.doc['text'])

    print(f"{doc_id:<5} | {score:<5} | {keyword:<15} | {text}")
```
```typescript TypeScript
res = lambdaDB.collections.query({
    collectionName: collectionName,
    size: 10,
    requestBody: {
        query: {
            bool: [
                {
                    queryString: {
                        query: "I hate managing servers",  // Main search query
                        defaultField: "text"               // Search in text field
                    }
                },
                {
                    queryString: {
                        query: "keyword:serverless"       // Filter by keyword
                    },
                    occur: "must"
                }
            ]
        }
    }
})

// Display results
console.log("üîç Search Results:")
for (const result of res.docs) {
    const docId = String(result.doc.id);
    const score = result.score.toFixed(2);
    const keyword = String(result.doc.keyword);
    const text = String(result.doc.text);

    console.log(`${docId.padEnd(5)} | ${score.padEnd(5)} | ${keyword.padEnd(15)} | ${text}`);
}
```
</CodeGroup>

Response:

<CodeGroup>
```python Python
doc3  | 0.92  | ['serverless', 'infrastructure'] | The key aspect is that developers don't need to explicitly provision or manage servers. The cloud provider handles all server management automatically.
doc1  | 0.48  | serverless      | Serverless computing does not mean no servers are involved. It refers to a cloud computing model where the server management is abstracted away from developers.
```
```typescript TypeScript
doc3  | 0.92  | ['serverless', 'infrastructure'] | The key aspect is that developers don't need to explicitly provision or manage servers. The cloud provider handles all server management automatically.
doc1  | 0.48  | serverless      | Serverless computing does not mean no servers are involved. It refers to a cloud computing model where the server management is abstracted away from developers.
```
</CodeGroup>

Why these results? doc3 scored highest because it directly mentions "manage servers", while doc1 matched on "server management" and "serverless computing".

## üîç Step 6: Hybrid search

Now let's combine full-text search with vector similarity for more comprehensive results. This is where LambdaDB really shines:

<CodeGroup>
```python Python
res = lambda_db.collections.query(
    collection_name=collection_name,
    size=10,
    query={
        "l2": [  # L2 normalization combines scores
            {
                "queryString": {
                    "query": "I hate managing servers",
                    "defaultField": "text"
                }
            },
            {
                "knn": {  # K-nearest neighbors vector search
                    "field": "vector",
                    "k": 5,
                    "queryVector": [
                        0.9, 0.8, 0.7, 0.6, 0.5,
                        0.4, 0.3, 0.2, 0.1, 1.0
                    ]
                }
            }
        ]
    }
)

# Display hybrid search results
print("üîÑ Hybrid Search Results:")
for result in res.docs:
    doc_id = str(result.doc['id'])
    score = f"{result.score:.2f}"
    keyword = str(result.doc['keyword'])
    text = str(result.doc['text'])

    print(f"{doc_id:<5} | {score:<5} | {keyword:<15} | {text}")
```
```typescript TypeScript
res = lambdaDB.collections.query({
    collectionName: collectionName,
    size: 10,
    requestBody: {
        query: {
            l2: [  // L2 normalization combines scores
                {
                    queryString: {
                        query: "I hate managing servers",
                        defaultField: "text"
                    }
                },
                {
                    knn: {  // K-nearest neighbors vector search
                        field: "vector",
                        k: 5,
                        queryVector: [
                            0.9, 0.8, 0.7, 0.6, 0.5,
                            0.4, 0.3, 0.2, 0.1, 1.0
                        ]
                    }
                }
            ]
        }
    }
})

// Display hybrid search results
console.log("üîÑ Hybrid Search Results:")
for (const result of res.docs) {
    const docId = String(result.doc.id);
    const score = result.score.toFixed(2);
    const keyword = String(result.doc.keyword);
    const text = String(result.doc.text);

    console.log(`${docId.padEnd(5)} | ${score.padEnd(5)} | ${keyword.padEnd(15)} | ${text}`);
}
```
</CodeGroup>

Response:

<CodeGroup>
```python Python
doc3  | 0.71  | ['serverless', 'infrastructure'] | The key aspect is that developers don't need to explicitly provision or manage servers. The cloud provider handles all server management automatically.
doc2  | 0.52  | cloud           | Instead, it refers to a cloud computing model where developers can build and run applications without having to manage the underlying infrastructure.
doc1  | 0.43  | serverless      | Serverless computing does not mean no servers are involved. It refers to a cloud computing model where the server management is abstracted away from developers.
```
```typescript TypeScript
doc3  | 0.71  | ['serverless', 'infrastructure'] | The key aspect is that developers don't need to explicitly provision or manage servers. The cloud provider handles all server management automatically.
doc2  | 0.52  | cloud           | Instead, it refers to a cloud computing model where developers can build and run applications without having to manage the underlying infrastructure.
doc1  | 0.43  | serverless      | Serverless computing does not mean no servers are involved. It refers to a cloud computing model where the server management is abstracted away from developers.
```
</CodeGroup>

**Score normalization options:**
- `rrf` (Reciprocal Rank Fusion): Great for combining rankings from different search methods
- `l2` (L2 Normalization): Normalizes scores using L2 norm
- `mm` (Min-Max Normalization): Simple linear scaling to 0-1 range

## üßπ Step 7: Clean up

When you're finished experimenting, clean up your resources:

<CodeGroup>
```python Python
lambda_db.collections.delete(collection_name=collection_name)
```
```typescript TypeScript
lambdaDB.collections.delete({collectionName: collectionName})
```
</CodeGroup>

## üöÄ Next steps

- **Apply for early access:** [https://lambdadb.ai/early-access](https://lambdadb.ai/early-access?utm_source=docs)
- **Advanced Queries**: Explore complex patterns in our [Query Guide](/guides/search/overview)
- **Bulk Operations**: Learn about large-scale data ingestion in our [Bulk Operations Guide](/guides/documents/bulk-upsert-data)
- **API Reference**: Comprehensive documentation at our [API Reference](/reference/api/introduction)

## ü§ù Support

Need help? Visit our [Community Forum](https://discord.gg/6qtmgtj342) for support and discussions.